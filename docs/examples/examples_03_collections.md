---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.13.6
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---


# Collections

(examples-collections-construction)=

## Collection construction

The `Collection` class is a versatile way of grouping and manipulating Magpylib  objects. When objects are added to a Collection they are added by reference (**not copied**) to the attributes `children` (list of all objects), `sources` (list of the sources) and `sensors` (list of the sensors). These attributes are ordered lists. New additions are always added at the end.

```{code-cell} ipython3
import magpylib as magpy

loop = magpy.current.Loop()
sens = magpy.Sensor()

col = magpy.Collection(loop, sens)

print(f"children: {col.children}")
print(f"sources:  {col.sources}")
print(f"sensors:  {col.sensors}")
```

To manipulate existing collections, one can use the `add` and `remove` methods:

```{code-cell} ipython3
col.add(magpy.magnet.Cuboid())
col.remove(sens)

print(f"children: {col.children}")
print(f"sources:  {col.sources}")
print(f"sensors:  {col.sensors}")
```

The operators `+` and `-` provide a similar functionality,

```{code-cell} ipython3
col = col - loop
col = col + magpy.magnet.Cylinder()

print(f"children: {col.children}")
print(f"sources:  {col.sources}")
print(f"sensors:  {col.sensors}")
```

However, it must be noted that using `+` and `-` results in copies of the Collection, while `add` and `remove` does not.

The `+` operator is defined for all Magpylib objects. Adding objects returns a collection.

```{code-cell} ipython3
what_is_it = loop + sens
print(what_is_it)
```

Collections have `__getitem__` through the attribute `children` defined. This allows using collections as iterators,

```{code-cell} ipython3
for child in col:
    print(child)
```

and makes it possible to directly reference to a child object:

```{code-cell} ipython3
print(col[0])
```

Finally, it is worth mentioning that collections do not allow duplicate sources. They will automatically be removed. However, sources can be part of multiple collections.

(examples-collections-compound)=

## Collections as compounds

The compound is an advanced Magpylib philosophy. The idea is that a compound object, made up of multiple individual sources and sensors can be treated like single object itself. 

For this purpose, the collection has itself `position` and `orientation` attributes that span a local coordinate reference frame. Whenever a child is added to the collection it has a `position` and `orientation` in the local frame. All operations acting on the collection will then only move the local frame around, and not change child positions within it. Operations acting directly on the child itself will move the child also in the local frame.

The collection `position` and `orientation` attributes allow users to track and manipulate compound object motion.

```{code-cell} ipython3
import numpy as np
import magpylib as magpy

# construct coil compound
coil = magpy.Collection()
for z in np.linspace(-.5, .5, 5):
    coil.add(magpy.current.Loop(current=1, diameter=20, position=(0,0,z)))

coil = coil.move((0,0,-5)) + coil.copy(position=(0,0,5))

# treat compound object like single object
coil.rotate_from_angax(np.linspace(0,360,60)[1:], 'x')
coil.position = np.linspace((0,0,0), (20,0,0), 60)

coil.set_children_styles(path_show=False)
coil.show(backend='plotly', animation=3)
```

The compound philisophy is also followed when computing the magnetic field. Collections behave like single source inputs in the functions `getB` and `getH`. The field that is returned is simply the the sum of the fields of all child sources. In the following example the field generated by the coil compound above is computed at position $(0,0,0)$:

```{code-cell} ipython3
coil.reset_path()

B = magpy.getB(coil, (0,0,0))
print(B)
```
